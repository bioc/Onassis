---
title: "Onassis: Ontology Annotation and Semantic Similarity software"
author: "Eugenia Galeota"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{Onassis: Ontology Annotation and Semantic Similarity software}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r importa, echo=FALSE,eval=TRUE, message=FALSE}
library(Onassis)
library(data.table)
library(DT)
library(htmltools)
library(BiocStyle)
```
# Introduction to OnASSis 

<b>OnASSiS</b> (Ontology Annotations and Semantic Similarity software) is a package that uses Conceptmapper, an Apache UIMA (Unstructured Information Management Architecture) dictionary lookup tool to retrieve dictionary terms in a given text. https://uima.apache.org/downloads/sandbox/ConceptMapperAnnotatorUserGuide/ConceptMapperAnnotatorUserGuide.html  
In particular, a Conceptmapper wrapper, specific for the biomedical domain, ccp-nlp, (https://github.com/UCDenver-ccp/ccp-nlp) has been personalized to retrieve concepts from OBO ontologies in a given text with different settable options.
The package also provides the possibility to annotate Gene Expression Omnibus (GEO) metadata retrieved using `r BiocStyle::Biocpkg("GEOmetadb")` or hight througput sequencing metadata from `r BiocStyle::Biocpkg("SRAdb")` with concepts from any given ontology. It is also possible to annotate genes, histone marks and histone modifications.

The semantic similarity module uses different semantic similarity measures to determine the semantic similarity of concepts in a given ontology, groups of concepts or experiments and samples annotated with ontology terms. 
This step is particularly useful for a better retrieval of data of interest from public repositories such as GEO http://www.ncbi.nlm.nih.gov/geo/ or SRA http://www.ncbi.nlm.nih.gov/sra. 
The semantic similarity module has been developed on the basis of the Java slib http://www.semantic-measures-library.org/sml.
To run Onassis Java (>= 1.8) is needed. 

# Retrieving public repositories metadata

Public repositories contain thousands of experiments and samples that are difficult to mine. Annotating the description of this data with controlled vocabularies or ontology terms could improve the retrieval of data of interest both programmatically or manually [@galeota2016ontology].
One of the most straightforward ways to retrieve GEO metadata is the `r BiocStyle::Biocpkg("GEOmetadb")` package. In order to use it through Onassis the user should download the SQLite database following the instructions provided in the vignette of the package (https://www.bioconductor.org/packages/release/bioc/vignettes/GEOmetadb/inst/doc/GEOmetadb.html). Since users are usually interested in getting experiments or samples we provide functions to help the retrieval of their metadata without the need of explicitly making queries to the database.  

## Handling GEO (Gene Expression Omnibus) Metadata

To ease the usage of `r BiocStyle::Biocpkg("GEOmetadb")` Onassis provides several functions to retrieve data of interest without explicitly using SQL queries. Firstly it is necessary to get a connection to the database. The user should provide the path of the SQLite file downloaded. If not found the function automatically downloads the file into the current working directory and returns a connection to the database. Since the download process of the database could be slow, we have provided an already available dataset for the subsequent analyses. Users can skip this section and go directly to the [Annotating text with Ontology Concepts] section.    

```{r connectTodb, echo=TRUE,eval=FALSE}
## Running this function might take a long time if the database has to be downloaded.
geo_con <- connectToGEODB(system.file(getwd(), 'GEOmetadb.sqlite'))

#Showing the experiment types available in GEO
experiments <- experiment_types(geo_con)

#Showing the organism types available in GEO
species <- organism_types(geo_con)

#Retrieving the metadata associated to experiment type "Methylation profiling by high througput sequencing"
methylation <- getGEOMetadata(geo_con, 'Methylation profiling by high throughput sequencing', 'Homo sapiens')

#Retrieving Human gene expression data, knowing the GEO platform identifier, e.g. the Affymetrix Human Genome U133 Plus 2.0 Array
expression <- getGEOMetadata(geo_con, 'Expression profiling by array', gpl='GPL570')
```

The experiment types available are the following:

```{r experimentTypesshow, echo=FALSE, eval=TRUE}
experiments <- readRDS(system.file('extdata', 'vignette_data', 'experiment_types.rds', package='Onassis'))
head(experiments)
```

The organisms available are the following:

```{r speciesShow, echo=FALSE,eval=TRUE}
species <- readRDS(system.file('extdata', 'vignette_data', 'organisms.rds', package='Onassis'))
head(species)
```

To easily obtain a data frame with the metadata of interest the function `getGEOmetadata` can be used. The function takes as parameters the connection to the database and one of the experiment types available. Optionally it is possible to specify the organism and the platform. To load the data of the previous query run:

```{r loadgeoMetadata, echo=TRUE, eval=TRUE}
methylation <- readRDS(system.file('extdata', 'vignette_data', 'GEOmethylation.rds', package='Onassis'))
getwd()
```

```{r printmeta, echo=FALSE,eval=TRUE}

methylation_tmp <- methylation
methylation_tmp$experiment_summary <- sapply(methylation_tmp$experiment_summary, function(x) substr(x, 1, 50))
DT::datatable(methylation_tmp, rownames=FALSE, 
              caption = htmltools::tags$caption(
                style = 'caption-side: top-left; text-align: left;',
                'Table 1: ', htmltools::em('Methylation profiling by high througput sequencing metadata from GEOmetadb.')),
              options=list(
                pageLength =5,
                autoWidth = TRUE, 
                scrollX='300px',
                rownames=FALSE))
              #  columnDefs = list(list(targets=10,
              #                         render = JS(
              #                           "function(data, type, row, meta) {",
              #                           "return type === 'display' && data.length > 50 ?",
              #                           "'<span title=\"' + data + '\">' + data.substr(0, 50) + '...</span>' : data;",
              #                           "}")
              #  )))), callback = JS('table.page("next").draw(false);'))

```

## Handling SRA (Sequence Read Archive) Metadata

As for GEO, it is possible to retrieve metadata of high througput sequencing data stored in SRA. To query the database the `r BiocStyle::Biocpkg("SRAdb")` package is available. To facilitate the retrieval of experiment types in SRA, the function `library_strategies` can be used. Filters for the sample's material (*GENOMIC*, *TRANSCRIPTOMIC*, *METAGENOMIC*...), the species and the center hosting the data are allowed.
For example, to obtain SRA metadata of ChIP-Seq human samples and Bisulfite sequencing samples, without explicitly querying the db with SQL statements the following lines of code can be used. Since the database file is quite large, as for GEOmetadb, users can skip this part and directly load the resulting dataset.  

```{r connectSRA, echo=TRUE,eval=FALSE}
# Connection to the SRAmetadb
sra_con <- connectToSRADB()

# Query for the ChIP-Seq experiments contained in GEO for human cell lines 
sra_chip_seq <- getSRAMetadata(sra_con, library_strategy='ChIP-Seq', library_source='GENOMIC', taxon_id=9606, center_name='GEO')

# The following example allows to retrieve Bisulfite sequencing samples' metadata.
bisulfite_seq <- getSRAMetadata(sra_con, library_strategy='Bisulfite-Seq', library_source='GENOMIC', taxon_id=9606, center_name='GEO' )


```

To load already selected ChIP-seq data run the following : 

```{r readCHIP, echo=TRUE, eval=TRUE}
sra_chip_seq <- readRDS(system.file('extdata', 'vignette_data', 'GEO_human_chip.rds',  package='Onassis'))
```

```{r printchromatinIP, echo=FALSE,eval=TRUE}

DT::datatable(head(sra_chip_seq, 20), rownames=FALSE, 
  caption = htmltools::tags$caption(
    style = 'caption-side: top-left; text-align: left;',
    'Table: ', htmltools::em('ChIP-Seq metadata obtained from SRAdb.')),
  options=list(
  pageLength =5,
  autoWidth = TRUE, 
  scrollX='300px',
  rownames=FALSE, 
columnDefs = list(list(targets=9,
           render = JS(
    "function(data, type, row, meta) {",
    "return type === 'display' && data.length > 50 ?",
    "'<span title=\"' + data + '\">' + data.substr(0, 50) + '...</span>' : data;",
    "}")
))), callback = JS('table.page("next").draw(false);'))
                       
```

# Annotating text with Ontology Concepts

Onassis has the capability of annotating any text with dictionary terms. More specifically, we are using as dictionaries the concepts contained in OBO (http://www.obofoundry.org/) ontologies in order to use the structure of the ontology to find relationships between different samples annotated with different ontology concepts. Onassis' text annotator, `EntityFinder` is based on a Java implementation of the Conceptmaper tool (https://uima.apache.org/downloads/sandbox/ConceptMapperAnnotatorUserGuide/ConceptMapperAnnotatorUserGuide.html), that defines a particular type system, the CCP type system, to annotate text with ontology concepts [@Verspoor:2009b]. The Java source code with the definition of the type system and the wrapper for Conceptmapper are available at (https://github.com/UCDenver-ccp/ccp-nlp/tree/master/ccp-nlp-wrapper-conceptmapper).  

## Data preparation

Input text can be provided to `EntityFinder`, the object that calls Conceptmapper to annotate text, in different formats:

  * The path of a directory containing named documents. 
  * The path of a single file containing multiple documents. In this case each row contains the name/identifier of the document followed by a '|' separator and the text to annotate. 

It is also possito to annotate text from a data frame with the `annotateDF` function. In this case users should provide

  * A data frame in which each row represents a document. The values of the first column of the data frame will be used as column identifiers and the content of the other columns will be considered as the text of the document. For metadata retrieved from `r BiocStyle::Biocpkg("GEOmetadb")` anb `r BiocStyle::Biocpkg("SRAdb")` a preprocessing step is applied to retrieve data of interest. 

Any type of text content is allowed in text files. 

## Creation of a Conceptmapper Dictionary

Conceptmapper dictionaries are XML files with a set of entries specified by the xml tag ```<token>```  with a canonical name (the name of the entry) and one or more variants (synonyms).  Additional properties are allowed. The following code represents a sample of the Conceptmapper dictionary obtained from the Brenda OBO ontology.  

```xml 
   <?xml version="1.0" encoding="UTF-8" ?>
   <synonym>
      <token id="http://purl.obolibrary.org/obo/BTO_0005205" canonical="cerebral artery">
	      <variant base="cerebral artery"/>
      </token>
      <token id="http://purl.obolibrary.org/obo/BTO_0002179" canonical="184A1N4 cell">
	      <variant base="184A1N4 cell"/>
	      <variant base="A1N4 cell"/>
      </token>
      <token id="http://purl.obolibrary.org/obo/BTO_0003871" canonical="uterine endometrial cancer cell">
	      <variant base="uterine endometrial cancer cell"/>
	      <variant base="endometrial cancer cell"/>
	      <variant base="uterine endometrial carcinoma cell"/>
	      <variant base="endometrial carcinoma cell"/>
      </token>
  </synonym>
```

To build Conceptmapper dictionaries from OBO ontologies in OBO or OWL format, Onassis provides the S4 class `CMdictionary`. The dictionary representation consists of

  * `dictLocation` The path of the dictionary file
  * `dictInfo` Info about the dictionary. It includes the type of dictionary (e.g. OBO, ENTREZ...), the source file  from which the dictionary has been created, the synonym types and eventually the id of the organism.
  * `dictRef` java reference to the Conceptmapper dictionary created

The function `dictionaryTypes` shows the types of dictionary that can be created through Onassis. 

```{r dictionaryTypes, echo=TRUE, eval=TRUE}
dictTypes <-  dictionaryTypes()
head(dictTypes)
```

Dictionaries can be built with different options. 
We firstly downloaded an OBO ontology from (http://www.berkeleybop.org/ontologies/bto.obo). Alternatively the following file can be downloaded https://sourceforge.net/projects/onassis/files/BrendaTissue.obo/download. To build a dictionary from an OBO file the `CMdictionary` class provides the `buildDictionary` method.

To create a dictionary for histone marks, histone modification and human Entrez gene names users can run the following code. If not specified, this function will automatically download the gene_info.gz file from ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene_info.gz.

To use a previously created or a custom dictionary it is possible to skip the building part and assing a reference to the Conceptmapper XML file throught the same function, using as dictType the value 'CMDICT'. We have provided a Conceptmapper dictionary built from BRENDA ontology at the following link: https://sourceforge.net/projects/onassis/files/cmDict-BrendaTissue.xml/download 

The function dict `CMdictionary` can be used to easily create a dictionary. 

```{r createBrendaAndTargetDict, echo=TRUE,eval=FALSE, message=FALSE}

#Creation of a dictionary from the file BrendaTissue.obo
brenda_dict <- CMdictionary(inputFile=system.file(getwd(), 'BrendaTissue.obo'), outputdir=getwd(), synonymType='ALL')

# Creation of a dictionary for ChIP-seq targets
targets <- CMdictionary(dictType='TARGET', taxID=9606)

# If a Conceptmapper dictionary is already available the dictType CMDICT can be specified and the corresponding file loaded
brenda_dict <- CMdictionary(inputFile=system.file(getwd(), 'cmDict-BrendaTissue.xml'), dictType = 'CMDICT')

```

## Setting the options for the annotator

An S4 class, `CMoptions` sets the configuration parameters to run Conceptmapper. Eeach combination of parameters is associated to an integer index stored in the slot `paramValueIndex`.  
CMoptions is a class that represents Conceptmapper configurations. It allows users to show and set the possible combinations of different parameters for Conceptmapper running. The function `showCMoptions` shows all the possible configuration combinations. To set the options the function `CMoptions` can be used, using as parameters the paramValueIndex corresponding to the desired combination, or a list of parameters to set. `CMargs` method shows the current options settings. 
 
In the case of tissues 

```{r settingOptions, echo=TRUE,eval=TRUE}

#Showing configuration permutations 
list_opts <- showCMoptions()  

#Setting the combination of parameters through the paramValueIndex value
myopts <- CMoptions(40)

#Showing the current options
CMargs(myopts)

# Alternatively it is possible to choose a combination of parameters passing a list. In this case the paramValueIndex is automatically updated based on the value of the other arguments
CMargs(myopts) <- as.list(c("CONTIGUOUS_MATCH", "CASE_IGNORE", "BIOLEMMATIZER", "NONE", "OFF", "YES", "EXACT_ONLY"))
```


## Running the Conceptmapper to find entities

The class `EntityFinder` has methods to find concepts of any OBO ontology in a given text provided in a single file or a directory of files. The method `annotateDF` instead is used to annotate data frames where the first column contains the document identifier and the second column the text to annotate. The function 'annotate' runs the entity finder on the given input. For example, to annotate the methylation metadata obtained from GEO with tissue and cell line concpets belonging to BRENDA ontology (http://www.brenda-enzymes.info/) the following instructions can be used

```{r annotateDF, echo=TRUE, eval=FALSE}

methylation_brenda_annot <- annotate(methylation[sample(nrow(methylation), 20),c('gsm', 'title', 'source_name_ch1', 'characteristics_ch1', 'description')], dictionary=brenda_dict, options=myopts)

```

The resulting table contains a column with the document/sample identifier. Each row representes an annotation for the given document. The annotation is reported with the term_id, the term name, its URL in the obo format and the sentence of the document from which the annotation has been extracted.

```{r showmethilationresults, echo=FALSE, eval=TRUE, message=FALSE}

methylation_brenda_annot <- readRDS(system.file('extdata', 'vignette_data', 'methylation_brenda_annot.rds', package='Onassis'))
DT::datatable(head(methylation_brenda_annot, 20), rownames=FALSE, 
  caption = htmltools::tags$caption(
    style = 'caption-side: top-left; text-align: left;',
    'Table: ', htmltools::em('Annotations of the methylation profiling by high througput sequencing metadata obtained from GEO with BRENDA ontology concepts')),
  options=list(
  pageLength =10,
  autoWidth = TRUE, 
  scrollX='300px',
  rownames=FALSE, 
columnDefs = list(list(targets=1,
           render = JS(
    "function(data, type, row, meta) {",
    "return type === 'display' && data.length > 50 ?",
    "'<span title=\"' + data + '\">' + data.substr(0, 50) + '...</span>' : data;",
    "}")
))), callback = JS('table.page("next").draw(false);'))
                 
    
```

\r
\r
In the following example the function `annotate` is used to retrieve gene names and histone modifications in the set of test samples provided in the Onassis. To create the dictionary the gene_info.gz file has been downloaded from (ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene_info.gz). Alternatively the function automatically downloads the gene_info.gz file.   

```{r annotateGenes, echo=TRUE, eval=FALSE, message=FALSE}
#Creating the dictionary of genes, this operation might take a while. 
targets <- CMdictionary(dictType='CMDICT', inputFile = system.file('extdata', 'cmDict-Target.xml', package='Onassis'))

#setting the proper options
myopts <- CMoptions(227)
#Finding the TARGET entities
target_entities <- annotate(system.file('extdata', 'testsamples', package='Onassis'), options = myopts, dictionary=targets) 
```


```{r annotateGenesVAL, echo=FALSE, eval=TRUE, message=FALSE}
#Instantiating the EntityFinder
#Creating the dictionary
target_entities <- readRDS(system.file('extdata', 'vignette_data', 'target_entities.rds', package='Onassis')) 
DT::datatable(target_entities[sample(nrow(target_entities), 20),], rownames=FALSE, 
  caption = htmltools::tags$caption(
    style = 'caption-side: top-left; text-align: left;',
    'Table: ', htmltools::em('Annotations of ChIP-seq test metadata obtained from SRAdb and stored into files with the TARGETs (genes and histone variants)')),
  options=list(
  pageLength =10,
  autoWidth = TRUE, 
  scrollX='100px',
  rownames=FALSE, 
columnDefs = list(list(targets= c(0,1,2,3,4),
           render = JS(
    "function(data, type, row, meta) {",
    "return type === 'display' && data.length > 50 ?",
    "'<span title=\"' + data + '\">' + data.substr(0, 50) + '...</span>' : data;",
    "}")
))), callback = JS('table.page("next").draw(false);'))

```


## Semantic similarity 

With Onassis it is possible to quantify the semantic similarity between the concepts of a given ontology using different semantic similarity measures. 
`Similarity` is an S4 class that wraps some methods of the Java library slib \url{http://www.semantic-measures-library.org/sml/} [@harispe2014semantic]. The class has methods to build a semantic graph starting from OBO ontology concepts and their hierarchical relationships. The library allows the computation of semantic similarity between single terms (pairwise measures), but also between group of terms groupwise measures). Pairwise measures are based on the underlying structure of the ontology. Roughly speaking, they can be classified in two categories: edge_based and information-content based measures. The first rely only on the structure of the ontology, while the latter also consider the information that each term in the ontology carries. Groupwise measures compute semantic similarity between groups of concepts. These can be indirect if they compute the pairwise similarity between each couple of terms belonging to the different groups or direct, if they consider the set of concepts as a whole. Onassis also provides the possibility of computing the semantic similarity between documents/samples.

The function `showSimilarities` shows all the possible measures supported by Onassis. For details about the measures run `{?Similarity}` 

```{r similarity, echo=TRUE, eval=TRUE, message=FALSE}
#Instantiating the Similarity
similarities <- showSimilarities()
```

The function similarity builds a semantic graph from an OBO ontology and computes the semantic similarity. The function can call the methods `sim`, `groupsim` and `samplesim` that in turn are used to compute the similarity between two terms of the ontology, between two list of terms of the ontology and between samples/documents annotated with terms of the ontology. The following example shows the pairwise similarities between BRENDA concepts obtained annotating the methylation samples' metadata.  To compute the similarity the <b>resnik</b> information content based measure has been selected. This measure computes the similarity between two concepts based on the information content of the most informative common ancestors of the compared concepts. The <b> seco </b> measure estimates the specificity of the concepts based on the number of concepts they subsumers. 

```{r computing measures, echo=TRUE, eval=FALSE, message=FALSE}

found_terms <- unique(methylation_brenda_annot$term_url)
n <- length(found_terms)

ontologyfile <- system.file(getwd(), 'BrendaTissue.obo')
pairwise_results <- data.frame(term1 = character(0), term2= character(0), value = double(0L))
for(i in 1:(n-1)){
  term1 <- as.character(found_terms[i])
  j = i + 1 
  for(k in j:n){
    term2 <- as.character(found_terms[k])
    two_term_similarity <- similarity(ontologyfile,  term1, term2 )
    new_row <- cbind(term1, term2, two_term_similarity)
    pairwise_results <- rbind(pairwise_results, new_row )
  }
}
pairwise_results <- unique(pairwise_results)
pairwise_results <- merge(pairwise_results, methylation_brenda_annot[, c('term_url', 'term_name')], by.x='term1', by.y='term_url', all.x=TRUE)
colnames(pairwise_results)[length(colnames(pairwise_results))] <- 'term1_name'
pairwise_results <- merge(pairwise_results, methylation_brenda_annot[, c('term_url', 'term_name')], by.x='term2', by.y='term_url', all.x=TRUE)
colnames(pairwise_results)[length(colnames(pairwise_results))] <- 'term2_name'
pairwise_results <- unique(pairwise_results)

```


```{r showing_similarity1, echo=FALSE, eval=TRUE, message=FALSE}

pairwise_results <- readRDS(system.file('extdata', 'vignette_data', 'pairwise_results.rds', package='Onassis'))
DT::datatable(pairwise_results[sample(nrow(pairwise_results), 20),], rownames=FALSE, 
  caption = htmltools::tags$caption(
    style = 'caption-side: top-left; text-align: left;',
    'Table: ', htmltools::em('Pairwise similarities of BRENDA terms annotating the Methylation profiling by high througput sequencing metadata')),
  options=list(
  pageLength =10,
  autoWidth = TRUE, 
  scrollX='100px',
  rownames=FALSE, 
columnDefs = list(list(targets= 1,
           render = JS(
    "function(data, type, row, meta) {",
    "return type === 'display' && data.length > 50 ?",
    "'<span title=\"' + data + '\">' + data.substr(0, 50) + '...</span>' : data;",
    "}")
))), callback = JS('table.page("next").draw(false);'))

```

In the following code the semantic similarity between two groups of terms is computed using the <b>ui</b> measure, a groupwise direct measure that includes the intersection and the union of the set of ancestors of the two groups of concepts. 

```{r groupwise_measures, echo=TRUE, eval=FALSE, message=FALSE}

ontologyfile <- system.file(getwd(), 'BrendaTissue.obo')
term_list1 <- c("http://purl.obolibrary.org/obo/BTO_0001546", "http://purl.obolibrary.org/obo/BTO_0000664", "http://purl.obolibrary.org/obo/BTO_0003807")
term_list2 <- c("http://purl.obolibrary.org/obo/BTO_0000759", "http://purl.obolibrary.org/obo/BTO_0000759", "http://purl.obolibrary.org/obo/BTO_0000664")

sim_t1_t2 <- similarity(ontologyfile, term_list1, term_list2)
```

```{r showGroupWiseResults, echo=FALSE, eval=TRUE, message=FALSE}
print('0.4358974')
```

It is also possible to compute the semantic similarity between samples annotated with different ontology terms.

```{r samples_similarity, echo=TRUE, eval=FALSE, message=FALSE}

annotated_samples <- as.character(as.vector(unique(methylation_brenda_annot$sample_id)))
n <- length(annotated_samples)


samples_results <- data.frame(sample1 = character(0), sample2= character(0), value = double(0L))
for(i in 1:(n-1)){
  sample1 <- as.character(annotated_samples[i])
  j = i + 1 
  for(k in j:n){
    sample2 <- as.character(annotated_samples[k])
    two_samples_similarity <- similarity(ontologyfile, sample1, sample2, methylation_brenda_annot )
    new_row <- cbind(sample1, sample2, two_samples_similarity)
    samples_results <- rbind(samples_results, new_row )
  }
}
```

```{r showing_similarity, echo=FALSE, eval=TRUE, message=FALSE}

samples_results <- readRDS(system.file('extdata', 'vignette_data', 'samples_similarity.rds', package='Onassis'))

DT::datatable(head(samples_results, 20), rownames=FALSE, 
  caption = htmltools::tags$caption(
    style = 'caption-side: top-left; text-align: left;',
    'Table: ', htmltools::em("Pairwise similarities of samples in th the Methylation profiling by high througput sequencing metadata, annotated with different BRENDA concepts'")),
  options=list(
  pageLength =10,
  autoWidth = TRUE, 
  rownames=FALSE))

```

# References
