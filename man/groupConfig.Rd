% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/similarity-methods.R
\docType{methods}
\name{groupConfig}
\alias{groupConfig}
\alias{groupConfig<-}
\alias{groupConfig,Similarity-method}
\alias{groupConfig<-,Similarity-method}
\title{\code{groupConfig}}
\usage{
groupConfig(object)

groupConfig(object) <- value

\S4method{groupConfig}{Similarity}(object)

\S4method{groupConfig}{Similarity}(object) <- value
}
\arguments{
\item{object}{instance of class \code{\link{Similarity-class}}}

\item{value}{See details}
}
\value{
groupwise configured measure for the similarity object provided as input

instance of the Similarity class with the new grouprwise option.
}
\description{
This method shows the value of the groupwise configuration used to compute semantic similarities between groups of concepts.

Sets the groupwise measure to compute the semantic similarity between groups of concepts. For available meausres use the method listSimilarities().
}
\details{
The following measures are indirect groupwise measures, meaning that they are used to aggregate individual pairwise measures.
\itemize{
\item{'min'}{: Minimum of the pairwise similarities of the concepts in the two groups}
\item{'average'}{: Average of the pairwise similarities of the concepts in the two groups}
\item{'max'}{: Max of the pairwise similarities of the concepts in the two groups}
\item{'bma'}{: Best match average}
\item{'bmm'}{: Best match max}
}
Direct groupwise measures directly compare the sets of concepts considering the features of both sets.
\itemize{
\item{'ui'}{: Considers the intersection and the union of the set of ancestors of the two groups of concepts:

\eqn{ sim(group_u, group_v) = | intersection( A(group_u), A(group_v)) | \code{/} | union( A(group_u), A(group_v)) | )}
}
\item{'nto_max'}{: Normalized max Term Overlap, computes the groupwise semantic similarity considering the inclusive set of ancestors of the two groups of concepts.

\eqn{sim(group_u, group_v) = | intersection( A(group_u), A(group_v)) | \code{/} | max( |A(group_u)|, |A(group_v)| ) |}

}
\item{'lee'}{: Computes the groupwise semantic similarity considering the inclusive set of ancestors of the two groups of conceps.

\eqn{ sim(group_u, group_v) = | union( A(group_u), A(group_v)) |}

}

\item{'lp'}{: Computes the groupwise semantic similarity between two groups of concepts as the depth of the longest shared path from the root node}

\item{'gic'}{: Computes the groupwise semantic similarity between two groups of concepts as the ration between the information content of the concepts in the intersection of the ancestors in the two groups and the information content of the concepts in the union of the ancestors in the two groups.

\eqn{ sim(group_u, group_v) = IC_intersection / IC_union}
}
\item{'batet'}{: Computes the groupwise semantic similarity between two groups of concepts considering the union and intersection of ancestors normalized on the number of concepts in the ontology.

\eqn{ sim(group_u, group_v) = |(union( A(group_u), A(group_v) ) - intersection(A(group_u), A(group_v)))| /  ( |(union( A(group_u), A(group_v) )| * tot_concepts )}
}
}
}
\examples{
sim <- new('Similarity')
groupConfig(sim)
sim <- new('Similarity')
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
groupConfig(sim) <- 'ui'

}
