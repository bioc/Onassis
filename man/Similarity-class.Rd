% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllClasses.R, R/AllConstructors.R,
%   R/AllFunctions.R, R/AllGenerics.R, R/similarity-methods.R
\docType{class}
\name{Similarity-class}
\alias{Similarity-class}
\alias{Similarity-constructor}
\alias{Similarity}
\alias{similarity}
\alias{similarityInstance}
\alias{similarityInstance<-}
\alias{icConfig}
\alias{icConfig<-}
\alias{pairwiseConfig}
\alias{pairwiseConfig<-}
\alias{pairwiseConfigRef}
\alias{pairwiseConfigRef<-}
\alias{groupwiseConfigRef}
\alias{groupwiseConfigRef<-}
\alias{groupConfig}
\alias{groupConfig<-}
\alias{ontology}
\alias{ontology<-}
\alias{showOpts}
\alias{groupsim}
\alias{samplesim}
\alias{multisim}
\alias{similarityInstance,Similarity-method}
\alias{similarityInstance}
\alias{similarityInstance<-,Similarity-method}
\alias{similarityInstance<-}
\alias{icConfig,Similarity-method}
\alias{icConfig}
\alias{icConfig<-}
\alias{pairwiseConfigRef,Similarity-method}
\alias{pairwiseConfigRef}
\alias{pairwiseConfigRef<-,Similarity-method}
\alias{pairwiseConfigRef<-}
\alias{pairwiseConfig,Similarity-method}
\alias{pairwiseConfig}
\alias{pairwiseConfig<-,Similarity-method}
\alias{pairwiseConfig<-}
\alias{groupwiseConfigRef,Similarity-method}
\alias{groupwiseConfigRef}
\alias{groupwiseConfigRef<-,Similarity-method}
\alias{groupwiseConfigRef<-}
\alias{groupConfig,Similarity-method}
\alias{groupConfig}
\alias{groupConfig<-,Similarity-method}
\alias{groupConfig<-}
\alias{showOpts,Similarity-method}
\alias{showOpts}
\alias{ontology<-,Similarity-method}
\alias{ontology<-}
\alias{ontology,Similarity-method}
\alias{ontology}
\alias{groupsim,Similarity,character,character-method}
\alias{groupsim}
\alias{samplesim,Similarity,character,character,data.frame-method}
\alias{samplesim}
\alias{multisim,list,list,character,character-method}
\alias{multisim}
\title{Similarity class to compute similarities between concepts in ontologies and samples annotated with different concepts
\code{Similarity-class}}
\usage{
Similarity(pairwiseConfig = NA_character_, icConfig = NA_character_,
  groupConfig = NA_character_)

similarity(ontologyFile, termlist1, termlist2, annotatedtab = NA,
  pairConf = c("resnik", "seco"), groupConf = "ui")

similarityInstance(object)

similarityInstance(object) <- value

icConfig(object)

icConfig(object) <- value

pairwiseConfig(object)

pairwiseConfig(object) <- value

pairwiseConfigRef(object)

pairwiseConfigRef(object) <- value

groupwiseConfigRef(object)

groupwiseConfigRef(object) <- value

groupConfig(object)

groupConfig(object) <- value

ontology(object)

ontology(object) <- value

showOpts(object)

groupsim(object, termList1, termList2)

samplesim(object, sample1, sample2, annotated_df)

multisim(similarities, annotations, sample1, sample2, aggregating_function)

\S4method{similarityInstance}{Similarity}(object)

\S4method{similarityInstance}{Similarity}(object) <- value

\S4method{icConfig}{Similarity}(object)

\S4method{icConfig}{Similarity}(object) <- value

\S4method{pairwiseConfigRef}{Similarity}(object)

\S4method{pairwiseConfigRef}{Similarity}(object) <- value

\S4method{pairwiseConfig}{Similarity}(object)

\S4method{pairwiseConfig}{Similarity}(object) <- value

\S4method{groupwiseConfigRef}{Similarity}(object)

\S4method{groupwiseConfigRef}{Similarity}(object) <- value

\S4method{groupConfig}{Similarity}(object)

\S4method{groupConfig}{Similarity}(object) <- value

\S4method{showOpts}{Similarity}(object)

\S4method{ontology}{Similarity}(object) <- value

\S4method{ontology}{Similarity}(object)

\S4method{groupsim}{Similarity,character,character}(object, termList1,
  termList2)

\S4method{samplesim}{Similarity,character,character,data.frame}(object, sample1,
  sample2, annotated_df)

\S4method{multisim}{list,list,character,character}(similarities, annotations,
  sample1, sample2, aggregating_function = "mean")
}
\arguments{
\item{pairwiseConfig}{the pairwise configuration}

\item{icConfig}{the information content configuration}

\item{groupConfig}{the groupwise configuration}

\item{ontologyFile}{the file in OBO or RDF format to build the graph}

\item{termlist1}{The URI or character vector of URIs belonging to the first set or the sample id of an annotated data frame}

\item{termlist2}{The URI or character vector of URIs belonging to the second  set or the sample id of the annotated data frame}

\item{annotatedtab}{The data frame of annotations}

\item{pairConf}{a configuration for the pairwise meausres. Defaults to resnik and seco.}

\item{groupConf}{one of the allowed configurations for groupwise measures}

\item{object}{Instance of the class \code{\link{Similarity-class}}}

\item{value}{the reference to a java Similarity object}

\item{termList1}{A vector of URIs of ontology terms in the format \url{http://purl.obolibrary.org/obo/Ontology_id} (e.g \url{http://purl.obolibrary.org/obo/BTO_0004732})}

\item{termList2}{A vector of URIs of ontology terms}

\item{sample1}{A sample ID with its annotations available in a data frame}

\item{sample2}{A sample ID with its annotations available in a data frame}

\item{annotated_df}{data frame with annotations obtained using entityFinder. The data frame should have at least a column named 'sample_id' with the sample identifier and a column named 'term_url' with the URL of the ontology terms annotating the sample. The ontology terms must belong to the ontology loaded in the Similarity class.}

\item{similarities}{a list of Similarity instances, one for each ontology used to annotate the data}

\item{annotations}{a list of annotated data frames obtained using annotateDF or findEntities, one for each ontology}

\item{aggregating_function}{A function used to aggregate the single similarities obtained from each ontology annotation. The function should be applied to a numeric vector. The default value is 'mean'}
}
\value{
instance of the class Similarity to compute semantic similarities based on the configured measures

the similarity value based on the configured measures

The java reference to an object of class Similarity

The object of class Similarity with a new instance of the java Similarity class

The measure used to compute concepts' information content

The similarity object with the new information conten measure set

The reference to the pairwise configuration used to compute semantic similarity

The pairwise measure

instance of the Similarity class with the new pairwise option.

groupwise configured measure for the similarity object provided as input

instance of the Similarity class with the new grouprwise option.

groupwise configured measure for the similarity object provided as input

instance of the Similarity class with the new grouprwise option.

the list of pairwise, information content and groupwise measures to compute the semantic similarities

The Similarity object where 'ontology' slot refers to the Java graph created

Ontology object

the semantic similarity of the two provided groups of concepts

The semantic similarity between the samples sample1 and sample2

The aggregate semantic similarity between the samples sample1 and sample2
}
\description{
Similarity is a class that wraps some methods of the Java library slib \url{http://www.semantic-measures-library.org/sml/}. Starting from OBO ontologies it is possible to build semantic graphs that allow the computation of different similarity measures between concepts belonging to the same ontology, group of concepts, samples annotated with different ontology concepts. Further details about the graph based semantic similarity measures are available at \url{http://www.semantic-measures-library.org/sml/index.php?q=doc_graph_based_advanced}

this constructr initializes the Similarity class to compute the similarity between couple of terms, couple of samples, or group of terms

this function computes the similarity between couple of terms, couple of samples, or group of terms

Method similarityInstance

Method similarityInstance<-

Method icConfig

Method icConfig<-

Method pairwiseConfig

Method pairwiseConfig<-

Method pairwiseConfigRef

Method pairwiseConfigRef<-

Method groupwiseConfigRef

Method groupwiseConfigRef<-

Method groupConfig

Method groupConfig<-

Method ontology

Method ontology<-

Method showOpts

Method groupsim

Method samplesim

Method multisim

This method retrieves the java object referencing the Similarity class

\code{similarityInstance<-}

This method retrieves the configuration of the intrinsic information content measure

This method sets the configuration of the intrinsic information content measure by taking as parameter the short flag associated to the information measure. To have details about the available short flags see the pairwiseConfig help

This method retrieves the reference to the Java configuration used to compute semantic similarities.

configures the pairwise java object to compute semantic similarity between two concepts of a given ontology, by passing as input the java reference to one of the allowed pairwise semantic similarity measures. For a complete list check the details section of the function pairwiseConfig.

This method shows the value of the pairwise configuration.

and configures the pairwise measure to compute semantic similarity between two concepts of a given ontology.To set the pairwise measure one of the available short flags described in details should be used.

This method shows the value of the groupwise configuration used to compute semantic similarities between groups of concepts.

Sets the groupwise measure to the reference of a groupwise measure to the semantic similarity between groups of concepts. For available meausres see the groupConfig function's details.

This method shows the value of the groupwise configuration used to compute semantic similarities between groups of concepts.

Sets the groupwise measure to compute the semantic similarity between groups of concepts. For available meausres use the method showOpts(sim).

This method shows a list of the possible measures to compute pairwise and groupwise semantic similarity between concepts

This method creates a semantic graph to compute semantic similarity between concepts. It takes as input an OBO ontology in RDF, OWL or OBO format.

This method shows the ontology.

This method computes the semantic similarity between two groups of terms of a given ontology.

This method computes the semantic similarity between two named samples annotated with a group of ontolgy terms belonging to the same ontology

This method computes the semantic similarity between samples annotated with different ontology terms from different ontologies
}
\details{
The following methods can be applied to Similarity

\code{\link{ontology<-}} \cr
\code{\link{pairwiseConfig}} \cr
\code{\link{groupConfig}} \cr
\code{\link{showOpts}} \cr
\code{\link{sim}} \cr
\code{\link{groupsim}} \cr
\code{\link{samplesim}} \cr

The following measures can be used to compute semantic similarities between two concepts.
\itemize{
\item{'edge_rada_lca'} {: Computes the similarity of two concepts based on the shortest path linking the two concepts.

\eqn{sim(u,v) = 1 /sp(u,v)}

}
\item{'edge_wupalmer'}{: Computes the similarity of two concepts based on the depth of the concepts and the depth of their most specific common ancestor

\eqn{sim(u,v) = depth(MSCA[u,v]) / (depth(u) + depth(v))}

}
\item{'edge_resnik'}{: Computes the similarity of two concepts based on the shortest path between the concepts and the maximum depth of the taxonomy

\eqn{ (2 * max_depth - min_sp(u,v)) / (2 * max_depth) }

max_depth is the maximum depth in the ontology

sp(u,v) is the shortest path legnth between u and v
}
\item{'edge_leachod'}{: Computes the similarity of two concepts based on the shortest path as Rada but also considering the depth of the ontology

\eqn{sim(u,v) = -log( (sp(u,v) + 1) / 2 * max_depth )}

}
\item{'edge_slimani'}{: Computes the similarity of two concepts based on the depth of the most specific common ancesto and the max depth of the concepts

\eqn{sim(u,v) = 2 * depth(MCA) / ((depth(u) + depth(v) + 1) * pf ))
}

depth(MCA) is the maximum depth of the most common ancestor of the concepts

 pf is a penalization factor used when concepts belong to the same hierarchy
}
}
The following measures require the specification of an additional meausre to compute the information content of nodes.
\itemize{
\item{'lin'}{: Computes the similarity between two concepts based on the information content of the two concepts and the information content of the most informative common ancestor of the two concepts

\eqn{ sim(u, v) = (2 * IC(MICA)) / ( IC(u) + IC(v) )}

IC(MICA) is the information content of the most informative common ancestor of u and v. MICA is the concept in the ancestors of both u and v that maximizes the Information Content measure.

}
\item{'resnik'}{: Computes the similarity between two concepts based on the information content of the most informative common ancestors of the compared concepts

\eqn{ sim(u,v) = IC(MICA)}
}


\item{'schlicker'}{: Computes the similarity between two concepts based on the information concent of the most informative common ancestor of the compared concepts and its probability of occurrence

\eqn{ sim(u,v) = (2 * IC(MICA)) / ( IC(u) + IC(v)) * (1 - Prob_MICA)}

Prob_MICA is the probability of occurrence of the most informative common ancestor of the compared concepts
}
\item{'jaccard'}{: Computes the similarity between two concepts based on the information content of the most informative common ancestor.

\eqn{ sim(u, v) = IC(MICA) / (IC(u) + IC(v) - IC(MICA)) } if the sum of the IC of the concepts is different from the IC of the MICA else sim(u, v) = 0.
}

\item{'sim'}{: This measure is based on \code{lin} similarity

\eqn{sim(u, v) = lin(u, v) - (1 - (1 / (1+ IC(MICA))))}

}
\item{'jc_norm'}{: Computes the similarity between two concepts based on the IC of the most informative ancestor of the concpets

\eqn{ sim(u,v) = 1 - (IC(u) + IC(v) - 2 * IC(MICA)) / 2}

}
}
Information content based measures require the configuration parameter for estimating concept specificity. Intrinsic estimation uses the topological properties of the taxonomic backbone of the semantic graph. There are different options:
\itemize{
\item{'zhou'}{: Intrinsic estimation of the specificity of the concepts based on their depth in the ontology.

\eqn{IC(c) = k( 1 - log(D(c))/log(|C|)) + (1 - k) (log(max(depth(x)))/ log(depth_max))}

k is a factor to adjust the weight of the two items of the equation

D(c) is the number of hyponims of concept c

|C| is the number of concepts in the ontology

depth(c) is the maximum depth of concept c

depth_max is the maximum depth in the ontology
}
\item{'resnik_1995'}{: Intrinsic estimation of the specificity of concepts based on the number of ancestors of the concept.

\eqn{IC(c) = |A(c)|}
}
\item{'seco'}{Intrinsic estimation of the specificity of the concepts based on the number of concepts they subsume.

\eqn{IC(c) = 1 - ( log(D(c) / log(|C|) )}

D(c) is the number of hyponims of concept c

|C| is the number of concepts in the ontology
}
\item{'sanchez'}{: Intrinsic estimation of the specificity of the concepts based on the number of leaves and the number of subsumers of the concepts

\eqn{IC(c) = -log(x / nb_leaves + 1) } with \eqn{x = |leaves(c)| / |A(c)|}

nb_leaves is the represents the number of leaves corresponding to the root node of the hierarchy

leaves(c) is the number of leaves corresponding to the concept c

|A(c)| is the number of concepts that subsume c

}
\item{'anc_norm'}{: Intrinsic estimation of the specificity of concepts based on the number of ancestors of a given concept normalized on the number of concepts in the ontology.}
\item{'depth_min_non_linear'}{: Intrinsic estimation of the specificity of concepts based on their minimum depth.}
\item{'depth_max_non_linear'}{: Intrinsic estimation of the specificity of concepts based on their maximum depth.}
}

The following measures are indirect groupwise measures, meaning that they are used to aggregate individual pairwise measures.
\itemize{
\item{'min'}{: Minimum of the pairwise similarities of the concepts in the two groups}
\item{'average'}{: Average of the pairwise similarities of the concepts in the two groups}
\item{'max'}{: Max of the pairwise similarities of the concepts in the two groups}
\item{'bma'}{: Best match average}
\item{'bmm'}{: Best match max}
}
Direct groupwise measures directly compare the sets of concepts considering the features of both sets.
\itemize{
\item{'ui'}{: Considers the intersection and the union of the set of ancestors of the two groups of concepts:

\eqn{ sim(group_u, group_v) = | intersection( A(group_u), A(group_v)) | \code{/} | union( A(group_u), A(group_v)) | )}
}
\item{'nto_max'}{: Normalized max Term Overlap, computes the groupwise semantic similarity considering the inclusive set of ancestors of the two groups of concepts.

\eqn{sim(group_u, group_v) = | intersection( A(group_u), A(group_v)) | \code{/} | max( |A(group_u)|, |A(group_v)| ) |}

}
\item{'lee'}{: Computes the groupwise semantic similarity considering the inclusive set of ancestors of the two groups of conceps.

\eqn{ sim(group_u, group_v) = | union( A(group_u), A(group_v)) |}

}

\item{'lp'}{: Computes the groupwise semantic similarity between two groups of concepts as the depth of the longest shared path from the root node}

\item{'gic'}{: Computes the groupwise semantic similarity between two groups of concepts as the ration between the information content of the concepts in the intersection of the ancestors in the two groups and the information content of the concepts in the union of the ancestors in the two groups.

\eqn{ sim(group_u, group_v) = IC_intersection / IC_union}
}
\item{'batet'}{: Computes the groupwise semantic similarity between two groups of concepts considering the union and intersection of ancestors normalized on the number of concepts in the ontology.

\eqn{ sim(group_u, group_v) = |(union( A(group_u), A(group_v) ) - intersection(A(group_u), A(group_v)))| /  ( |(union( A(group_u), A(group_v) )| * tot_concepts )}
}
}
}
\section{Slots}{

\describe{
\item{\code{similarityInstance}}{The Java reference to the Java Similarity class.}

\item{\code{pairwiseConfig}}{The list of measures used to compute the semantic similarity between two concpets in the same ontology.}

\item{\code{pairwiseConfigRef}}{The reference to the Java object of type CMconf corresponding to the pairwise configuration}

\item{\code{groupConfig}}{The groupwise configuration to compute the semantic similarity between groups of concepts.}

\item{\code{icConfig}}{The information content measure}

\item{\code{groupwiseConfigRef}}{The reference to the Java configuration object for the computation of semantic similarity between groups of concepts}

\item{\code{ontology}}{The ontology to compute semantic similarities}
}}

\examples{
sim <- new('Similarity')

obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
sample_dict <- dictionary(inputFileOrDb=obo, outputdir=getwd(), synonymType='ALL')
myopts <- new('CMoptions')
paramValueIndex(myopts) <- 40
term_list1 <- c('http://purl.obolibrary.org/obo/CL_0000000', 'http://purl.obolibrary.org/obo/CL_0000236')
term_list2 <- c('http://purl.obolibrary.org/obo/CL_0000542')
sim <- similarity(obo, term_list1, term_list2)

obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
sample_dict <- dictionary(inputFileOrDb=obo, outputdir=getwd(), synonymType='ALL')
myopts <- CMoptions()
paramValueIndex(myopts) <- 40
term_list1 <- c('http://purl.obolibrary.org/obo/CL_0000000',
 'http://purl.obolibrary.org/obo/CL_0000236')
term_list2 <- c('http://purl.obolibrary.org/obo/CL_0000542')
sim <- similarity(obo, term_list1, term_list2)

sim <- Similarity()
similarityInstance(sim)
sim <- Similarity()
similarityInstance(sim) <-.jnew('iit/comp/epigen/nlp/similarity/Similarity')
sim <- Similarity()
icConfig(sim)
sim <- Similarity()
icConfig(sim) <- 'sanchez'
sim <- Similarity()
pairwiseConfigRef(sim)
sim <- Similarity()
pairwiseConfigRef(sim) <- c('resnik')
sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
pairwiseConfig(sim)
sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
pairwiseConfig(sim) <- 'edge_resnik'
 #The following configuration uses an information content based measure
 pairwiseConfig(sim) <- c('resnik', 'seco')
sim <- Similarity()
groupwiseConfigRef(sim)
sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
groupwiseConfigRef(sim) <- 'ui'
sim <- Similarity()
groupConfig(sim)
sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
groupConfig(sim) <- 'ui'

sim <- Similarity()
showOpts(sim)

sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo

sim <- Similarity()
ontology(sim)


sim <- Similarity()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
pairwiseConfig(sim) <- showOpts(sim)$pairwiseMeasures[9]
groupConfig(sim) <- showOpts(sim)$groupwiseMeasures[3]
similarity <- groupsim(sim, c('http://purl.obolibrary.org/obo/CL_0000542',
 'http://purl.obolibrary.org/obo/CL_0000236'),
c('http://purl.obolibrary.org/obo/CL_0000000'))
similarity

sim <- Similarity()

pairwiseConfig(sim) <- showOpts(sim)$pairwiseMeasures[9]
groupConfig(sim) <- showOpts(sim)$groupwiseMeasures[3]
ef <- EntityFinder()
opts <- CMoptions()
obo <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
ontology(sim) <- obo
sample_dict <- dictionary(inputFileOrDb=obo, outputdir=getwd(), synonymType='ALL')
sra_chip_seq <- readRDS(system.file('extdata', 'vignette_data', 'GEO_human_chip.rds',
  package='Onassis'))
chipseq_dict_annot <- annotate(sra_chip_seq[1:20,c('sample_accession', 'title',
 'experiment_attribute', 'sample_attribute', 'description')], dictionary=sample_dict,
  options=opts)
s <- samplesim(sim, as.character(as.vector(chipseq_dict_annot$sample_id[1])),
as.character(as.vector(chipseq_dict_annot$sample_id[7])) , chipseq_dict_annot)
ef <- EntityFinder()

opts <- CMoptions()

cell_dict_file <- system.file('extdata', 'sample.cs.obo', package='OnassisJavaLibs')
sample_dict <- dictionary(inputFileOrDb=cell_dict_file, outputdir=getwd(),
synonymType='ALL')
samples <- findEntities(ef, system.file('extdata', 'test_samples',
'test_samples.txt',
package='Onassis'), outDir=getwd(), multipleDocs=TRUE, configOpt=opts,
 cmDict=sample_dict)

d_dict_file <-  system.file('extdata', 'sample.do.obo', package='OnassisJavaLibs')
disease_dict <- dictionary(inputFileOrDb=d_dict_file,
outputdir=getwd(), synonymType='ALL')
disease <- findEntities(ef, system.file('extdata', 'test_samples',
'test_samples.txt', package='Onassis'),
 multipleDocs=TRUE, outDir=getwd(), configOpt=opts,
  cmDict=disease_dict)


cell_sim <- Similarity()
ontology(cell_sim) <- cell_dict_file

disease_sim <- Similarity()
ontology(disease_sim) <- d_dict_file

pairwiseConfig(cell_sim) <- showOpts(cell_sim)$pairwiseMeasures[9]
pairwiseConfig(disease_sim) <- showOpts(disease_sim)$pairwiseMeasures[9]
groupConfig(cell_sim) <- showOpts(cell_sim)$groupwiseMeasures[3]
groupConfig(disease_sim) <- showOpts(disease_sim)$groupwiseMeasures[3]
similarity <- multisim(list(cell_sim, disease_sim),
list(samples, disease),
as.character(as.vector(samples[1,1])),
as.character(as.vector(samples[5,1])), 'mean')
}
